'use strict';var q=require("outline");
class t{constructor(b,a,c=1){this._offsetMap=b;this._firstNode=a;this._blockOffsetSize=c}createSelectionFromOffsets(b,a,c){var e=this._firstNode;if(null===e)return null;var f=y(e,b,this._blockOffsetSize);let h=y(e,a,this._blockOffsetSize);void 0!==c&&(b=z(b,f,c,this,this._blockOffsetSize),f=y(e,b,this._blockOffsetSize),a=z(a,h,c,this,this._blockOffsetSize),h=y(e,a,this._blockOffsetSize));if(null===f||null===h)return null;c=f.key;e=h.key;const m=q.$getNodeByKey(c),k=q.$getNodeByKey(e);if(null===m||
null===k)return null;let l=0,d=0,g="element",n="element";"text"===f.type?(l=b-f.start,g="text",f=m.getNextSibling(),b!==a&&l===m.getTextContentSize()&&q.$isTextNode(f)&&(l=0,c=f.__key)):"inline"===f.type&&(c=m.getParentOrThrow().getKey(),l=a>f.start?f.end:f.start);"text"===h.type?(d=a-h.start,n="text"):"inline"===h.type&&(e=k.getParentOrThrow().getKey(),d=a>h.start?h.end:h.start);b=q.$createSelection();if(null===b)return null;b.anchor.set(c,l,g);b.focus.set(e,d,n);return b}getOffsetsFromSelection(b){var a=
b.anchor,c=b.focus,e=this._offsetMap;const f=a.offset;var h=c.offset;let m=b=-1;if("text"===a.type)a=e.get(a.key),void 0!==a&&(b=a.start+f);else{a=a.getNode().getDescendantByIndex(f);const k=e.get(a.getKey());void 0!==k&&(b=a.getIndexWithinParent()!==f?k.end:k.start)}"text"===c.type?(h=e.get(c.key),void 0!==h&&(m=h.start+c.offset)):(c=c.getNode().getDescendantByIndex(h),e=e.get(c.getKey()),void 0!==e&&(m=c.getIndexWithinParent()!==h?e.end:e.start));return[b,m]}}
function z(b,a,c,e,f){const h=c._offsetMap;e=e._offsetMap;const m=new Set;let k=b;for(;null!==a;){var l=a.key,d=h.get(l),g=a.end-a.start;m.add(l);void 0===d?k+=g:(l=d.end-d.start,l!==g&&(k+=g-l));g=a.prev;if(null!==g)a=g;else{for(a=a.parent;null!==a;)d=a.prev,null!==d&&(g=d.key,l=h.get(g),d=d.end-d.start,m.add(g),void 0===l?k+=d:(g=l.end-l.start,g!==d&&(k+=d-g))),a=a.parent;break}}c=c._firstNode;if(null!==c){a=y(c,b,f);for(b=!1;null!==a;){if(!m.has(a.key)){b=!0;break}a=a.parent}if(!b)for(;null!==
a;)b=a.key,m.has(b)||(f=e.get(b),b=a.end-a.start,void 0===f?k-=b:(f=f.end-f.start,b!==f&&(k+=f-b))),a=a.prev}return k}function y(b,a,c){for(;null!==b;){if(a<b.end+("element"!==b.type||0===c?1:0)){const e=b.child;if(null!==e){b=e;continue}return b}b=b.next;if(null===b)break}return null}
function A(b,a,c,e,f,h){let m=null,k=null;const l=a.length;for(let v=0;v<l;v++){{var d=b;var g=a[v];var n=c,r=e,w=f,u=h,p=r.get(g);if(void 0===p)throw Error("Minified Outline error #3; see codes.json for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");const x=d.offset;if(q.$isElementNode(p)){const B=p.__children;r=(p=0===B.length)?null:A(d,B,null,r,w,u);if(!d.prevIsBlock||p)d.prevIsBlock=!0,d.offset+=u;n={child:r,prev:null,next:null,type:"element",
start:x,end:x,key:g,parent:n};null!==r&&(r.parent=n);n.end=d.offset;w.set(g,n);g=n}else d.prevIsBlock=!1,u=q.$isTextNode(p),d=d.offset+=u?p.__text.length:1,d={child:null,prev:null,next:null,type:u?"text":"inline",start:x,end:d,key:g,parent:n},w.set(g,d),g=d}null===k?m=g:(g.prev=k,k.next=g);k=g}return m}
exports.$createOffsetView=function(b,a=1,c){c=(c||b._pendingEditorState||b._editorState)._nodeMap;const e=c.get("root");b=new Map;c=A({offset:0,prevIsBlock:!1},e.__children,null,c,b,a);return new t(b,c,a)};exports.OffsetView=t;
